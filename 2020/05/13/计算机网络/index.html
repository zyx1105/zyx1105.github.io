<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zyx1105.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="相对与上一个版本的计算机网路面试知识总结，这个版本增加了 “TCP协议如何保证可靠传输”包括超时重传、停止等待协议、滑动窗口、流量控制、拥塞控制等内容并且对一些已有内容做了补充。 一 OSI**与TCP&#x2F;IP各层的结构与功能,都有哪些协议** 五层协议的体系结构 学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP&#x2F;IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="https://zyx1105.github.io/2020/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Welcome to my Blog-Zzzzzz">
<meta property="og:description" content="相对与上一个版本的计算机网路面试知识总结，这个版本增加了 “TCP协议如何保证可靠传输”包括超时重传、停止等待协议、滑动窗口、流量控制、拥塞控制等内容并且对一些已有内容做了补充。 一 OSI**与TCP&#x2F;IP各层的结构与功能,都有哪些协议** 五层协议的体系结构 学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP&#x2F;IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image003.jpg">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image007.jpg">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image016.png">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image020.png">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image021.png">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image022.png">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image024.png">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image025.gif">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image027.jpg">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image028.gif">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image030.jpg">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image031.jpg">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image033.jpg">
<meta property="og:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image035.jpg">
<meta property="article:published_time" content="2020-05-13T01:19:58.660Z">
<meta property="article:modified_time" content="2020-05-13T01:19:58.661Z">
<meta property="article:author" content="Zyx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png">

<link rel="canonical" href="https://zyx1105.github.io/2020/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>计算机网络 | Welcome to my Blog-Zzzzzz</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Welcome to my Blog-Zzzzzz</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zyx1105.github.io/2020/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome to my Blog-Zzzzzz">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-13 09:19:58" itemprop="dateCreated datePublished" datetime="2020-05-13T09:19:58+08:00">2020-05-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>相对与上一个版本的计算机网路面试知识总结，这个版本增加了 “TCP协议如何保证可靠传输”包括超时重传、停止等待协议、滑动窗口、流量控制、拥塞控制等内容并且对一些已有内容做了补充。</p>
<p><strong>一</strong> <strong>OSI**</strong>与<strong><strong>TCP/IP</strong></strong>各层的结构与功能<strong><strong>,</strong></strong>都有哪些协议**</p>
<p><strong>五层协议的体系结构</strong></p>
<p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>
<p><img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" alt="五层协议的体系结构"></p>
<p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p>
<p><strong>1</strong> <strong>应用层</strong></p>
<p><strong>应用层**</strong>(application-layer<strong><strong>）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统</strong></strong>DNS<strong>，支持万维网应用的 <strong>HTTP</strong></strong>协议<strong>，支持电子邮件的 <strong>SMTP</strong></strong>协议**等等。我们把应用层交互的数据单元称为报文。</p>
<p><strong>域名系统</strong></p>
<p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.com、Oracle" target="_blank" rel="noopener">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.com、Cisco公司的域名是" target="_blank" rel="noopener">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com" target="_blank" rel="noopener">www.cisco.com</a> 等。</p>
<p><strong>HTTP**</strong>协议**</p>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p>
<p><strong>2</strong> <strong>运输层</strong></p>
<p><strong>运输层**</strong>(transport layer)<strong>**的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p><strong>运输层主要使用以下两种协议</strong></p>
<ol>
<li><strong>传输控制协议</strong> <strong>TCP</strong>（Transmisson Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>
<li><strong>用户数据协议</strong> <strong>UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>
</ol>
<p><strong>UDP</strong> <strong>的主要特点</strong></p>
<ol>
<li>UDP 是无连接的；</li>
<li>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li>
<li>UDP 是面向报文的；</li>
<li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信；</li>
<li>UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li>
</ol>
<p><strong>TCP</strong> <strong>的主要特点</strong></p>
<ol>
<li>TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li>
<li>每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li>
<li>TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li>
<li>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li>
<li>面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li>
</ol>
<p><strong>3</strong> <strong>网络层</strong></p>
<p><strong>在</strong> <strong>计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点，</strong> <strong>确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP</strong> <strong>协议</strong>，因此分组也叫 <strong>IP</strong> <strong>数据报</strong> ，简称 <strong>数据报</strong>。</p>
<p>这里要注意：<strong>不要把运输层的**</strong>“<strong>**用户数据报</strong> <strong>UDP ”**</strong>和网络层的<strong>**“ IP</strong> <strong>数据报**</strong>”<strong>**弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP**</strong>层**。</p>
<p><strong>4</strong> <strong>数据链路层</strong></p>
<p><strong>数据链路层**</strong>(data link layer)<strong>**通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的</strong> <strong>IP</strong> <strong>数据报组装程帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。<br> 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<p><strong>5</strong> <strong>物理层</strong></p>
<p>在物理层上所传送的数据单位是比特。<br> <strong>物理层**</strong>(physical layer)<strong>**的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p>
<p><strong>总结一下</strong></p>
<p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。图片来源：<a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">https://blog.csdn.net/yaopeng_2005/article/details/7064869</a><br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image003.jpg" alt="七层体系结构图"></p>
<p><strong>二</strong> <strong>TCP</strong> <strong>三次握手和四次挥手**</strong>(<strong><strong>面试常客</strong></strong>)**</p>
<p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<p><strong>漫画图解：</strong></p>
<p>图片来源：《图解HTTP》<br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png" alt="TCP三次握手"></p>
<p><strong>简单示意图：</strong><br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg" alt="TCP三次握手"></p>
<p>·    客户端–发送带有 SYN 标志的数据包–一次握手–服务端</p>
<p>·    服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</p>
<p>·    客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</p>
<p><strong>为什么要三次握手</strong></p>
<p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<p><strong>为什么要传回</strong> <strong>SYN</strong></p>
<p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
<p><strong>传了</strong> <strong>SYN,**</strong>为啥还要传** <strong>ACK</strong></p>
<p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<p><img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image007.jpg" alt="TCP四次挥手"></p>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<p>·    客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</p>
<p>·    服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</p>
<p>·    服务器-关闭与客户端的连接，发送一个FIN给客户端</p>
<p>·    客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</p>
<p><strong>为什么要四次挥手</strong></p>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>
<p><strong>三</strong> <strong>TCP**</strong>、<strong>**UDP</strong> <strong>协议的区别</strong></p>
<p><img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png" alt="TCP、UDP协议的区别"></p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<p><strong>四</strong> <strong>TCP</strong> <strong>协议如何保证可靠传输</strong></p>
<ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>停止等待协议</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 <strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<p><strong>停止等待协议</strong></p>
<p>·    停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；</p>
<p>·    在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</p>
<p><strong>1)</strong> <strong>无差错情况**</strong>:**</p>
<p><img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png" alt="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzE2LzE2NTQxZmE4YzM4MTZhOTA?x-oss-process=image/format,png"></p>
<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
<p><strong>2)</strong> <strong>出现差错情况（超时重传）**</strong>:**<br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png" alt="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzE2LzE2NTQxZmFlZmRmMjQ5YWI?x-oss-process=image/format,png"><br> 停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求</strong> <strong>ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续</strong> <strong>ARQ</strong> <strong>协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>3)</strong> <strong>确认丢失和确认迟到</strong></p>
<p>·    <strong>确认丢失</strong>：确认消息在传输过程丢失<br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png" alt="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzE2LzE2NTQxZmI2OTQxYTcxNjU?x-oss-process=image/format,png"><br> 当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：</p>
<p>\1.   丢弃这个重复的M1消息，不向上层交付。</p>
<p>\2.   向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</p>
<p>·    <strong>确认迟到</strong> ：确认消息在传输过程中迟到<br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image016.png" alt="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzE2LzE2NTQxZmRkODU5MjllNmI?x-oss-process=image/format,png"><br> A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：</p>
<p>\1.   A收到重复的确认后，直接丢弃。</p>
<p>\2.   B收到重复的M1后，也直接丢弃重复的M1。</p>
<p><strong>自动重传请求</strong> <strong>ARQ</strong> <strong>协议</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。</p>
<p><strong>优点：</strong> 简单</p>
<p><strong>缺点：</strong> 信道利用率低</p>
<p><strong>连续**</strong>ARQ<strong>**协议</strong></p>
<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<p><strong>滑动窗口</strong></p>
<p>·    TCP 利用滑动窗口实现流量控制的机制。</p>
<p>·    滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</p>
<p>·    TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p>
<p><strong>流量控制</strong></p>
<p>·    TCP 利用滑动窗口实现流量控制。</p>
<p>·    流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
<p>·    接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p><strong>拥塞控制</strong></p>
<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口**</strong>(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<p>·    <strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。<br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg" alt="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzEwLzE2NTIzNDhhZGEyYzhmZDA?x-oss-process=image/format,png"></p>
<p>·    <strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</p>
<p>·    <strong>快重传与快恢复：</strong><br> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。<br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image020.png" alt="快重传与快恢复"></p>
<p><strong>五</strong> <strong>在浏览器中输入**</strong>url<strong>**地址</strong> <strong>-&gt;&gt;</strong> <strong>显示主页的过程（面试常客）</strong></p>
<p>百度好像最喜欢问这个问题。</p>
<p>打开一个网页，整个过程会使用哪些协议</p>
<p>图解（图片来源：《图解HTTP》）：</p>
<p><img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image021.png" alt="状态码"></p>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这篇文章：</p>
<p>·    <a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></p>
<p><strong>六</strong> <strong>状态码</strong></p>
<p><img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image022.png" alt="状态码"></p>
<p><strong>七</strong> <strong>各种协议与**</strong>HTTP<strong>**协议之间的关系</strong></p>
<p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p>
<p>图片来源：《图解HTTP》</p>
<p><img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image024.png" alt="各种协议与HTTP协议之间的关系"></p>
<p><strong>八</strong> <strong>HTTP**</strong>长连接、短连接**</p>
<p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<p>Connection:keep-alive</p>
<p>·    1</p>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p><strong>HTTP**</strong>协议的长连接和短连接，实质上是<strong><strong>TCP</strong></strong>协议的长连接和短连接。**</p>
<p>—— <a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">《HTTP长连接、短连接究竟是什么？》</a></p>
<p><strong>写在最后</strong></p>
<p><strong>计算机网络常见问题回顾</strong></p>
<p>·    ①TCP三次握手和四次挥手、</p>
<p>·    ②在浏览器中输入url地址-&gt;&gt;显示主页的过程</p>
<p>·    ③HTTP和HTTPS的区别</p>
<p>·    ④TCP、UDP协议的区别</p>
<p>·    ⑤常见的状态码。</p>
<p><strong>建议</strong></p>
<p>非常推荐大家看一下 《图解HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>
<p><strong>一、**</strong>OSI<strong><strong>，</strong></strong>TCP/IP<strong>**，五层协议的体系结构，以及各层协议</strong></p>
<p><strong>OSI**</strong>分层** <strong>（**</strong>7<strong>**层）：</strong>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br> <strong>TCP/IP**</strong>分层（<strong><strong>4</strong></strong>层）：<strong>网络接口层、 网际层、运输层、 应用层。<br> **五层协议</strong> <strong>（**</strong>5<strong>**层）：</strong>物理层、数据链路层、网络层、运输层、 应用层。</p>
<p><strong>每一层的协议如下：</strong></p>
<p>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）<br> 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br> 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br> 传输层：TCP、UDP、SPX<br> 会话层：NFS、SQL、NETBIOS、RPC<br> 表示层：JPEG、MPEG、ASII<br> 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p>
<p><strong>HTTP**</strong>的长连接和短连接<strong>**?</strong></p>
<p>HTTP的长连接和短连接本质上是<strong>TCP**</strong>长连接和短连接**。HTTP属于应用层协议.</p>
<p><em>短连接<strong>:</strong>浏览器和服务器每进行一次<strong>HTTP</strong>操作，就建立一次连接，但任务结束就中断连接。</em></p>
<p><strong>长连接**</strong>:**当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>
<p>TCP短连接: client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作.短连接一般只会在 client/server间传递一次读写操作</p>
<p>TCP长连接: client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>
<p><strong>每一层的作用如下：</strong></p>
<p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br> 数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br> 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br> 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br> 会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br> 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br> 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>
<p><strong>运输层协议与网络层协议的区别？</strong></p>
<p>网络层协议负责的是提供主机间的逻辑通信<br> 运输层协议负责的是提供进程间的逻辑通信</p>
<p><strong>数据链路层协议可能提供的服务？</strong></p>
<p>成帧、链路访问、透明传输、可靠交付、流量控制、差错检测、差错纠正、半双工和全双工。最重要的是帧定界（成帧）、透明传输以及差错检测。</p>
<p><strong>二、**</strong>IP<strong>**地址的分类</strong></p>
<p>A类地址：以0开头， 第一个字节范围：0~127（1.0.0.1 - 126.255.255.254）；</p>
<p>B类地址：以10开头， 第一个字节范围：128~191（128.0.0.1 - 191.255.255.254）；</p>
<p>C类地址：以110开头， 第一个字节范围：192~223（192.0.0.1- 223.255.255.254）；</p>
<p>10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部）</p>
<p>IP地址与子网掩码相与得到主机号</p>
<p><strong>三、各种协议</strong></p>
<p><strong>3.1 ARP**</strong>是地址解析协议，简单语言解释一下工作原理。**</p>
<p>1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</p>
<p>2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。</p>
<p>3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p>
<p>4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。<br> <strong>广播发送**</strong>ARP<strong><strong>请求，单播发送</strong></strong>ARP<strong>**响应。</strong></p>
<p><strong>3.2 ICMP**</strong>协议：因特网控制报文协议。它是<strong><strong>TCP/IP</strong></strong>协议族的一个子协议，用于在<strong><strong>IP</strong></strong>主机、路由器之间传递控制消息。**</p>
<p><strong>3.3 TFTP**</strong>协议：是<strong><strong>TCP/IP</strong></strong>协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。**</p>
<p><strong>3.4 HTTP**</strong>协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。**</p>
<p><strong>3.5 DHCP**</strong>协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。一个局域网的网络协议，使用<strong><strong>UDP</strong></strong>协议工作，用途：给内部网络或网络服务供应商自动分配<strong><strong>IP</strong></strong>地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。**</p>
<p><strong>3.6 NAT**</strong>协议：网络地址转换属接入广域网<strong><strong>(WAN)</strong></strong>技术，是一种将私有（保留）地址转化为合法<strong><strong>IP</strong></strong>地址的转换技术，**</p>
<p><strong>3.7 RARP</strong></p>
<p>RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此<strong>RARP**</strong>只能用于具有广播能力的网络。**</p>
<p><strong>四、三次握手和四次挥手的具体过程：</strong></p>
<p><strong>三次握手：</strong></p>
<p>server处于Listen状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了；<br> 当client端socket执行connect连接时，首先发送SVN报文到server，进入SVN_SENT状态，等待server发送ACK；<br> server接受到SVN进入SVN_RCVD状态，（很短暂，一般查询不到），发送SVN+ACK给client端；<br> client端接受到server的ACK，发送ACK给server，server接收到后进入established状态，client也进入established状态。<br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image025.gif" alt="这里写图片描述"><br> <strong>建立**</strong>TCP<strong>**连接</strong><br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image027.jpg" alt="这里写图片描述"></p>
<p><strong>四次挥手：</strong></p>
<p>client发起断开连接，给server发送FIN，进入FIN_WAIT1状态，表示client想主动断开连接；<br> server接受到FIN字段后，会继续发送数据给client端，并发送ACK给client端，表明自己知道了，但是还没有准备好断开，请等我的消息；<br> 当server确定自己的数据已经发送完成，就发送FIN到client；<br> client接受到来自server的FIN，发送ACK给server端，表示可以断开连接了，再等待2ms，没有收到server端的数据后，表示可以正常断开连接。<br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image028.gif" alt="这里写图片描述"><br> <strong>断开**</strong>TCP<strong>**连接成功</strong><br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image030.jpg" alt="这里写图片描述"></p>
<p><strong>为什么**</strong>TIME_WAIT<strong><strong>状态还需要等</strong></strong>2*MSL<strong><strong>（</strong></strong>Max SegmentLifetime<strong><strong>，最大分段生存期）秒之后才能返回到</strong></strong>CLOSED<strong>**状态呢？</strong></p>
<p>因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SENT状态到ESTABLISH状态那样），但是我们必须假想网络是不可靠的，你无法保证你最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来<strong>重发可能丢失的**</strong>ACK<strong>**报文</strong>。</p>
<p><strong>为什么**</strong>TCP<strong>**连接要建立三次连接？</strong></p>
<p>为了防止失效的连接请求又传送到主机，因而产生错误。</p>
<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<p><strong>为什么要**</strong>4<strong>**次挥手？</strong></p>
<p><strong>TCP**</strong>协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，是一个全双工模式：**<br> 1、当主机A确认发送完数据且知道B已经接受完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给主机B。</p>
<p>2、主机B收到A发送的FIN，表示收到了，就会发送ACK回复。</p>
<p>3、但这是B可能还在发送数据，没有想要关闭数据口的意思，所以FIN与ACK不是同时发送的，而是等到B数据发送完了，才会发送FIN给主机A。</p>
<p>4、A收到B发来的FIN，知道B的数据也发送完了，回复ACK， A等待2MSL以后，没有收到B传来的任何消息，知道B已经收到自己的ACK了，A就关闭链接，B也关闭链接了。<br> <strong>确保数据能够完成传输。</strong></p>
<p><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></p>
<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 </p>
<p><strong>例子：</strong></p>
<p>三次握手：<br> A:“喂，你听得到吗？”A-&gt;SYN_SEND</p>
<p>B:“我听得到呀，你听得到我吗？”应答与请求同时发出 B-&gt;SYN_RCVD | A-&gt;ESTABLISHED</p>
<p>A:“我能听到你，今天balabala……”B-&gt;ESTABLISHED</p>
<p>四次挥手：<br> A:“喂，我不说了。”A-&gt;FIN_WAIT1</p>
<p>B:“我知道了。等下，上一句还没说完。Balabala…..”B-&gt;CLOSE_WAIT | A-&gt;FIN_WAIT2</p>
<p>B:”好了，说完了，我也不说了。”B-&gt;LAST_ACK</p>
<p>A:”我知道了。”A-&gt;TIME_WAIT | B-&gt;CLOSED</p>
<p>A等待2MSL,保证B收到了消息,否则重说一次”我知道了”,A-&gt;CLOSED</p>
<p><strong>五、在浏览器中输入**</strong><a href="http://www.baidu.com****后执行的全部过程" target="_blank" rel="noopener">www.baidu.com****后执行的全部过程</a>**</p>
<p>1、客户端浏览器通过<a href="https://blog.csdn.net/m0_37812513/article/details/78775629" target="_blank" rel="noopener">DNS解析</a>到<a href="http://www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。" target="_blank" rel="noopener">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></p>
<p>2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p>
<p>3、客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<p>4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p>
<p><strong>六、**</strong>TCP<strong><strong>和</strong></strong>UDP<strong>**的区别？</strong></p>
<table>
<thead>
<tr>
<th>区别</th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>1.连接</td>
<td>面向连接</td>
<td>面向非连接</td>
</tr>
<tr>
<td>2.可靠性</td>
<td>可靠</td>
<td>非可靠</td>
</tr>
<tr>
<td>3.有序性</td>
<td>有序</td>
<td>不保证有序</td>
</tr>
<tr>
<td>4.速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>5.量级</td>
<td>重量级</td>
<td>轻量级</td>
</tr>
<tr>
<td>6.拥塞控制或流量控制</td>
<td>有</td>
<td>没有</td>
</tr>
<tr>
<td>7</td>
<td>面向字节流，无记录边界</td>
<td>面向报文，有记录边界</td>
</tr>
<tr>
<td>8</td>
<td>只能单播</td>
<td>可以广播或组播</td>
</tr>
<tr>
<td>9.应用场景</td>
<td>效率低，准确性高</td>
<td>效率高，准确性低</td>
</tr>
</tbody></table>
<p><strong>TCP**</strong>对应的协议和<strong><strong>UDP</strong></strong>对应的协议**</p>
<p><strong>TCP**</strong>对应的协议：**</p>
<p>（1） FTP：定义了文件传输协议，使用21端口。</p>
<p>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</p>
<p>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。</p>
<p>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。</p>
<p>（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。</p>
<p><strong>UDP**</strong>对应的协议：**</p>
<p>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</p>
<p>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<p>（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p>
<p><strong>端口及对应的服务？</strong></p>
<table>
<thead>
<tr>
<th>服务</th>
<th>端口号</th>
<th>服务</th>
<th>端口号</th>
</tr>
</thead>
<tbody><tr>
<td>FTP</td>
<td>21</td>
<td>SSH</td>
<td>22</td>
</tr>
<tr>
<td>telnet</td>
<td>23</td>
<td>SMTP</td>
<td>25</td>
</tr>
<tr>
<td>Domain(域名服务器)</td>
<td>53</td>
<td>HTTP</td>
<td>80</td>
</tr>
<tr>
<td>POP3</td>
<td>110</td>
<td>NTP（网络时间协议）</td>
<td>123</td>
</tr>
<tr>
<td>MySQL数据库服务</td>
<td>3306</td>
<td>Shell或 cmd</td>
<td>514</td>
</tr>
<tr>
<td>POP-2</td>
<td>109</td>
<td>SQL Server</td>
<td>1433</td>
</tr>
</tbody></table>
<p><strong>TCP/IP**</strong>的流量控制？**</p>
<p>利用滑动窗口实现流量控制，如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p>
<p><strong>TCP**</strong>拥塞控制？**</p>
<p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</p>
<p>拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。</p>
<p><strong>几种拥塞控制方法：</strong></p>
<p><strong>慢开始**</strong>(slow-start )<strong><strong>、拥塞避免</strong></strong>(congestion avoidance )<strong><strong>、快重传</strong></strong>( fastretransmit )<strong><strong>和快恢复</strong></strong>( fastrecovery )<strong>**。</strong></p>
<p><strong>慢开始和拥塞避免</strong></p>
<p>发送方维持一个拥塞窗口cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。<br> 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。<br> <strong>慢开始算法：</strong>当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即<strong>由小到大逐渐增大发送窗口</strong>，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p>
<p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。<br> 另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。<br> 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：<br> 当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。<br> 当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。<br> 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。<br> <strong>拥塞避免算法：</strong>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。<br> 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。过程图如下：<br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image031.jpg" alt="这里写图片描述"></p>
<p><strong>快速重传：</strong></p>
<p>那就是收到3个相同的ACK。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行快速重传，快速重传做的事情有：</p>
<ol>
<li>把ssthresh设置为cwnd的一半</li>
<li>把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3)</li>
<li>重新进入拥塞避免阶段。</li>
</ol>
<p><strong>快速恢复：</strong></p>
<ol>
<li>当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3</li>
<li>再收到重复的ACK时，拥塞窗口增加1。</li>
<li>收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。</li>
</ol>
<p><strong>七、**</strong>IP<strong>**数据包的格式</strong></p>
<p>IP数据报由首部 和数据 两部分组成。首部由固定部分和可选部分 组成。首部的固定部分有20字节。可选部分的长度变化范围为1——40字节。固定部分的字段：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>位数（bit）</th>
<th>字段名</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>版本</td>
<td>4 Ipv4</td>
<td>首部长度</td>
<td>4（表示的最大数为15个单位，一个单位表示4字节）</td>
</tr>
<tr>
<td>服务类型</td>
<td>8 以前很少用</td>
<td>总长度</td>
<td>16 （首部和数据部分的总长度，因此数据报的最大长度为65535字节，即64KB，但是由于链路层的MAC都有一定的最大传输单元，因此IP数据报的长度一般都不会有理论上的那么大，如果超出了MAC的最大单元就会进行分片）</td>
</tr>
<tr>
<td>标识</td>
<td>16 （相同的标识使得分片后的数据报片能正确的重装成原来的数据报）</td>
<td>标志</td>
<td>3 （最低位MF=1表示后面还有分片，MF=0表示这是若干个数据报片的最后一个中间位DF=0才允许分片）</td>
</tr>
<tr>
<td>片偏移</td>
<td>片偏移指出较长的分组在分片后，某片在原分组中的相对位置，都是8字节的偏移位置</td>
<td>生存时间</td>
<td>数据报在网络中的生存时间，指最多经过路由器的跳数</td>
</tr>
<tr>
<td>协议</td>
<td>8 （指出该数据报携带的数据是何种协议，以使得目的主机的IP层知道应将数据部分上交给哪个处理程序）如ICMP=1 IGMP=2  TCP=6 EGP=8 IGP=9 UDP=17 Ipv6=41 OSPF=89</td>
<td>首部校验和</td>
<td>这个部分只校验首部，不包括数据部分，计算方法：将首部划分为多个16位的部分，然后每个16位部分取反，然后计算和，再将和取反放到首部校验和。接收方收到后按同样的方法划分，取反，求和，在取反，如果结果为零，则接收，否则就丢弃</td>
</tr>
<tr>
<td>源地址</td>
<td>32</td>
<td>目的地址</td>
<td>32</td>
</tr>
</tbody></table>
<p><strong>八、**</strong>TCP<strong>**数据报的格式？</strong></p>
<p><img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image033.jpg" alt="这里写图片描述"><br> 一个TCP报文段分为首部和数据两部分。首部由固定部分和选项部分组成，固定部分是20字节。TCP首部的最大长度为60。首部固定部分字段：<br> <img src="file:///C:/Users/zyx/AppData/Local/Temp/msohtmlclip1/01/clip_image035.jpg" alt="这里写图片描述"></p>
<p><strong>TCP**</strong>的<strong><strong>12</strong></strong>字节伪首部：**</p>
<table>
<thead>
<tr>
<th>源IP地址（4）</th>
<th>目的IP地址（4）</th>
<th>0 (1)</th>
<th>6(1) 代表这是TCP，IP协议中提到过</th>
<th>TCP长度（2）</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>TCP**</strong>数据报的格式？**</p>
<p>用户数据报UDP由首部和数据部分组成。首部只有8个字节，由4个字段组成，每个字段都是两个字节。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字节</th>
<th>字段名</th>
<th>字节</th>
</tr>
</thead>
<tbody><tr>
<td>源端口</td>
<td>2</td>
<td>目的端口</td>
<td>2</td>
</tr>
<tr>
<td>长度</td>
<td>2</td>
<td>检验和</td>
<td>2 （检验首部和数据，加12字节的伪首部）</td>
</tr>
</tbody></table>
<p><strong>UDP**</strong>的<strong><strong>12</strong></strong>字节伪首部：**</p>
<table>
<thead>
<tr>
<th>源IP地址（4）</th>
<th>目的IP地址（4）</th>
<th>0 (1)</th>
<th>17(1) 代表这是UDP</th>
<th>UDP长度（2）</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>以太网**</strong>MAC<strong>**帧格式？</strong></p>
<table>
<thead>
<tr>
<th>前导码</th>
<th>前定界符</th>
<th>目的地址</th>
<th>源目的地址</th>
<th>长度字段</th>
<th>数据字段</th>
<th>校验字段</th>
</tr>
</thead>
<tbody><tr>
<td>7B</td>
<td>1B</td>
<td>6B</td>
<td>6B</td>
<td>2B</td>
<td>46-1500</td>
<td>4B</td>
</tr>
</tbody></table>
<p><strong>九、了解交换机、路由器、网关的概念，并知道各自的用途</strong></p>
<p><strong>1**</strong>）交换机**</p>
<p>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。</p>
<p>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。</p>
<p>交换机被广泛应用于二层网络交换，俗称“二层交换机”。</p>
<p>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层和第七层，并因此而得名。</p>
<p><strong>2**</strong>）路由器**</p>
<p>路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。</p>
<p>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。</p>
<p><strong>说说静态路由和动态路由有什么区别。</strong></p>
<p>静态路由是由管理员手工配置的，适合比较简单的网络或需要做路由特殊控制。而动态路由则是由动态路由协议自动维护的，不需人工干预，适合比较复杂大型的网络。<br> 路由器能够自动地建立自己的路由表，并且能够根据实际实际情况的变化适时地进行调整。动态路由机制的运作依赖路由器的两个基本功能：对路由表的维护；路由器之间适时的路由信息交换。</p>
<p><strong>在**</strong>Linux<strong>**环境中怎么配置一条默认路由？</strong></p>
<p>在linux上可以用“route add default gw&lt;默认路由器 IP&gt;”命令配置一条默认路由。</p>
<p><strong>3**</strong>）网关**</p>
<p>网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。</p>
<p>在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。</p>
<p>在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。</p>
<p>网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。</p>
<p>对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</p>
<p><strong>4**</strong>）网络接口卡（网卡）的功能？**</p>
<p>（1）进行串行/并行转换。</p>
<p>（2）对数据进行缓存。</p>
<p>（3）在计算机的操作系统安装设备驱动程序。</p>
<p>（4）实现以太网协议。<br> <strong>5**</strong>）网桥的作用？**</p>
<p>网桥是一个局域网与另一个局域网之间建立连接的桥梁</p>
<p><strong>十、**</strong>IO<strong>**中同步与异步，阻塞与非阻塞区别</strong></p>
<p>同步和异步关注的是消息通信机制 (synchronous communication/asynchronous communication)<br> 所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br> 换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。<br> 而异步则是相反，<em>调用</em>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。</p>
<p>非阻塞：不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/13/%E6%B5%8B%E8%AF%95%E7%9F%A5%E8%AF%86/" rel="prev" title="测试知识">
      <i class="fa fa-chevron-left"></i> 测试知识
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zyx</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zyx</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
